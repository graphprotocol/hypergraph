import type { DocHandle } from '@automerge/automerge-repo';
import * as VariantSchema from '@effect/experimental/VariantSchema';
import * as Data from 'effect/Data';
import * as Schema from 'effect/Schema';
import { generateId } from './utils/generateId.js';

const {
  Class,
  Field,
  // FieldExcept,
  // FieldOnly,
  // Struct,
  // Union,
  // extract,
  // fieldEvolve,
  // fieldFromKey
} = VariantSchema.make({
  variants: ['select', 'insert', 'update'],
  defaultVariant: 'select',
});

export { Class };

export type Any = Schema.Schema.Any & {
  readonly fields: Schema.Struct.Fields;
  readonly insert: Schema.Schema.Any;
  readonly update: Schema.Schema.Any;
};

export type AnyNoContext = Schema.Schema.AnyNoContext & {
  readonly fields: Schema.Struct.Fields;
  readonly insert: Schema.Schema.AnyNoContext;
  readonly update: Schema.Schema.AnyNoContext;
};

export type Update<S extends Any> = S['update'];
export type Insert<S extends Any> = S['insert'];

export interface Generated<S extends Schema.Schema.All | Schema.PropertySignature.All>
  extends VariantSchema.Field<{
    readonly select: S;
  }> {}

/**
 * A field that represents a column that is generated by the store.
 */
export const Generated = <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S): Generated<S> =>
  Field({
    select: schema,
  });

export const Text = Schema.String;
// biome-ignore lint/suspicious/noShadowRestrictedNames: is part of a namespaces module and therefor ok
export const Number = Schema.Number;
export const Checkbox = Schema.Boolean;

export type DocumentContent = {
  entities?: Record<string, unknown>;
};

export class EntityNotFoundError extends Data.TaggedError('EntityNotFoundError')<{
  id: string;
  type: AnyNoContext;
  cause?: unknown;
}> {}

export type Entity<S extends AnyNoContext> = Schema.Schema.Type<S> & { type: string };

/**
 * Creates an entity model of given type and stores it in the repo.
 */
export const create = <const S extends AnyNoContext>(handle: DocHandle<DocumentContent>, type: S) => {
  // TODO: what's the right way to get the name of the type?
  // @ts-expect-error name is defined
  const typeName = type.name;
  const entityId = generateId();
  const encode = Schema.encodeSync(type.insert);

  return (data: Readonly<Schema.Schema.Type<Insert<S>>>): Entity<S> => {
    const encoded = encode(data);
    // apply changes to the repo -> adds the entity to the repo entites document
    handle.change((doc) => {
      doc.entities ??= {};
      doc.entities[entityId] = { ...encoded, '@@types@@': [typeName] };
    });

    return { id: entityId, ...encoded, type: typeName };
  };
};

/**
 * Update an existing entity model of given type in the repo.
 */
export const update = <const S extends AnyNoContext>(handle: DocHandle<DocumentContent>, type: S) => {
  const validate = Schema.validateSync(Schema.partial(type.update));
  const encode = Schema.encodeSync(type.update);
  const decode = Schema.decodeUnknownSync(type.update);

  // TODO: what's the right way to get the name of the type?
  // @ts-expect-error name is defined
  const typeName = type.name;

  return (id: string, data: Schema.Simplify<Partial<Schema.Schema.Type<Update<S>>>>): Entity<S> => {
    validate(data);

    // apply changes to the repo -> updates the existing entity to the repo entites document
    let updated: Schema.Schema.Type<S> | undefined = undefined;
    handle.change((doc) => {
      if (doc.entities === undefined) {
        return;
      }

      // TODO: Fetch the pre-decoded value from the local cache.
      const entity = doc.entities[id] ?? undefined;
      if (entity === undefined || typeof entity !== 'object') {
        return;
      }

      // TODO: Try to get a diff of the entitiy properties and only override the changed ones.
      updated = { ...decode(entity), ...data };
      doc.entities[id] = { ...encode(updated), '@@types@@': [typeName] };
    });

    if (updated === undefined) {
      throw new EntityNotFoundError({ id, type });
    }

    return { id, type: typeName, ...(updated as Schema.Schema.Type<S>) };
  };
};

/**
 * Deletes the exiting entity from the repo.
 */
const delete$ = (handle: DocHandle<DocumentContent>) => {
  return (id: string): boolean => {
    let result = false;

    // apply changes to the repo -> removes the existing entity by its id
    handle.change((doc) => {
      if (doc.entities?.[id] !== undefined) {
        delete doc.entities[id];
        result = true;
      }
    });

    return result;
  };
};

export { delete$ as delete };

/**
 * Queries for a list of entities of the given type from the repo.
 */
export function findMany<const S extends AnyNoContext>(
  handle: DocHandle<DocumentContent>,
  type: S,
): Readonly<Array<Entity<S>>> {
  const decode = Schema.decodeUnknownSync(type);
  // TODO: what's the right way to get the name of the type?
  // @ts-expect-error name is defined
  const typeName = type.name;

  // TODO: Instead of this insane filtering logic, we should be keeping track of the entities in
  // an index and store the decoded valeus instead of re-decoding over and over again.
  const entities = handle.docSync()?.entities ?? {};
  const filtered: Array<Entity<S>> = [];
  for (const id in entities) {
    const entity = entities[id];
    if (typeof entity === 'object' && entity != null && '@@types@@' in entity) {
      const types = entity['@@types@@'];
      if (Array.isArray(types) && types.includes(typeName)) {
        filtered.push({ ...decode({ ...entity, id }), type: typeName });
      }
    }
  }

  return filtered;
}

/**
 * Find the entity of the given type, with the given id, from the repo.
 */
export const findOne =
  <const S extends AnyNoContext>(handle: DocHandle<DocumentContent>, type: S) =>
  (id: string): Entity<S> | undefined => {
    const decode = Schema.decodeUnknownSync(type);

    // TODO: what's the right way to get the name of the type?
    // @ts-expect-error name is defined
    const typeName = type.name;

    // TODO: Instead of this insane filtering logic, we should be keeping track of the entities in
    // an index and store the decoded valeus instead of re-decoding over and over again.
    const entity = handle.docSync()?.entities?.[id];
    if (typeof entity === 'object' && entity != null && '@@types@@' in entity) {
      const types = entity['@@types@@'];
      if (Array.isArray(types) && types.includes(typeName)) {
        return { ...decode({ ...entity, id }), type: typeName };
      }
    }

    return undefined;
  };
